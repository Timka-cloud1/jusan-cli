package com.temirbolat.cli;

import java.io.*;
import java.nio.file.*;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.Arrays;
import java.util.Iterator;
import java.util.Scanner;

public class MyFile {
    // выводит список всех файлов и директорий для `path` - ls

    //listDirectory("/home/amanzhol.temirbolat/test");

    public static void listDirectory(String path) {
        File file = new File(path);
        String[] files = file.list();
        if (files == null) {
            System.out.println("Указанный путь не существует");
            return;
        }
        Arrays.stream(files).forEach(System.out::println);
    }

    public static void listPythonFiles(String path) {
        File file = new File(path);
        String[] files = file.list();
        if (files == null) {
            System.out.println("Указанный путь не существует");
            return;
        }
        Arrays.stream(files).filter((f) -> f.endsWith(".py")).forEach(System.out::println);
    }

    public static void isDirectory(String path) {
        File file = new File(path);
        if (checkExistingPath(file)) {
            return;
        }

        System.out.println(file.isDirectory());
    }

    // выводит `директория` или `файл` в зависимости от типа `path` - define
    public static void define(String path) {
        File file = new File(path);
        if (checkExistingPath(file)) {
            return;
        }
        if (file.isDirectory()) {
            System.out.println("директория");
        } else if (file.isFile()) {
            System.out.println("файл");
        }
    }

    // выводит права для файла в формате `rwx` для текущего пользователя - readmod
    public static void printPermissions(String path) {
        File file = new File(path);
        if (checkExistingPath(file)) {
            return;
        }

        StringBuilder sb = new StringBuilder("---");
        if (file.canRead()) {
            sb.setCharAt(0, 'r');
        }
        if (file.canWrite()) {
            sb.setCharAt(1, 'w');
        }
        if (file.canExecute()) {
            sb.setCharAt(2, 'x');
        }
        System.out.println(sb);
    }

    // устанавливает права для файла `path` - setmod

    public static void setPermissions(String path, String permissions) {
        File file = new File(path);
        if (checkExistingPath(file)) {
            return;
        }

        if (permissions.length() != 3) {
            System.out.println("Не правильно использована команда. Пример: r-x, rwx, --x");
            return;
        }
        if(permissions.charAt(0) != '-' && permissions.charAt(0) != 'r' || permissions.charAt(1) != '-' && permissions.charAt(1) != 'w' || permissions.charAt(2) != '-' && permissions.charAt(2) != 'x') {
            System.out.println("Не правильно использована команда. Пример: r-x, rwx, --x");
            return;

        }
        file.setReadable(permissions.charAt(0) == 'r');
        file.setWritable(permissions.charAt(1) == 'w');
        file.setExecutable(permissions.charAt(2) == 'x');


    }
    // выводит контент файла - cat
    public static void printContent(String path) {
        File file = new File(path);

        if (checkExistingPath(file)) {
            return;
        }
        if (file.isDirectory()) {
            System.out.println("Это директория, читать можно только файл");
            return;
        }

        try {
            BufferedReader reader = new BufferedReader(new FileReader(file));
            String strCurrentLine;
            while ((strCurrentLine = reader.readLine()) != null) {
                System.out.println(strCurrentLine);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // добавляет строке `# Autogenerated line` в конец `path` - append
    public static void appendFooter(String path) {
        File file = new File(path);

        if (checkExistingPath(file)) {
            return;
        }
        if (file.isDirectory()) {
            System.out.println("Это директория, добавлять футер можно только для файла");
            return;
        }
        try {
            FileWriter fileWriter = new FileWriter(file, true);
            fileWriter.append("# Autogenerated line");
            fileWriter.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // создает копию `path` в директорию `/tmp/${date}.backup` где, date - это дата в формате `dd-mm-yyyy`. `path` может быть директорией или файлом. При директории, копируется весь контент. - bc
    public static void createBackup(String path) {
        File file = new File(path);
        if (checkExistingPath(file)) {
            return;
        }
        DateTimeFormatter df = DateTimeFormatter.ofPattern("dd-MM-yyy");
        LocalDate localDate = LocalDate.now();
        File dest = new File("/tmp/" + df.format(localDate) + ".backup");
        if(dest.exists()) {
            try {
                deleteDirectoryRecursion(dest.toPath());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        if(file.isFile()) {
            dest.mkdir();
            try {
                InputStream in = new BufferedInputStream(new FileInputStream(file));
                OutputStream out = new BufferedOutputStream(new FileOutputStream(dest + "/" + file.getName()));
                byte[] buffer =new byte[1024];
                int len;
                while ((len = in.read(buffer)) > 0) {
                    out.write(buffer,0,len);
                    out.flush();
                }
            }catch (IOException e) {
                e.printStackTrace();
            }
            return;
        }



        Path sourcePath = file.toPath();
        Path destPath = dest.toPath();

        try {
            Files.walk(sourcePath).forEach((s) -> copy(s, destPath.resolve(sourcePath.relativize(s))));
        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private static void deleteDirectoryRecursion(Path path) throws IOException {
        if (Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS)) {
            try (DirectoryStream<Path> entries = Files.newDirectoryStream(path)) {
                for (Path entry : entries) {
                    deleteDirectoryRecursion(entry);
                }
            }
        }
        Files.delete(path);
    }
    private static void copy(Path source, Path dest) {
        try {
            Files.copy(source, dest, StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void printLongestWord(String path) {
        File file = new File(path);

        if (checkExistingPath(file)) {
            return;
        }
        if (file.isDirectory()) {
            System.out.println("Это директория, читать можно только файл");
            return;
        }

        try {
            BufferedReader reader = new BufferedReader(new FileReader(file));
            String strCurrentLine;
            String longest = "";
            while ((strCurrentLine = reader.readLine()) != null) {
                if(longest.length() < strCurrentLine.length()) {
                    longest = strCurrentLine;
                }
            }
            System.out.println(longest);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void help() {
        System.out.println("ls <path>               выводит список всех файлов и директорий для `path`\n" +
                "ls_py <path>            выводит список файлов с расширением `.py` в `path`\n" +
                "is_dir <path>           выводит `true`, если `path` это директория, в других случаях `false`\n" +
                "define <path>           выводит `директория` или `файл` в зависимости от типа `path`\n" +
                "readmod <path>          выводит права для файла в формате `rwx` для текущего пользователя\n" +
                "setmod <path> <perm>    устанавливает права для файла `path`\n" +
                "cat <path>              выводит контент файла\n" +
                "append <path>           добавляет строку `# Autogenerated line` в конец `path`\n" +
                "bc <path>               создает копию `path` в директорию `/tmp/${date}.backup` где, date - это дата в формате `dd-mm-yyyy`\n" +
                "greplong <path>         выводит самое длинное слово в файле\n" +
                "help                    выводит список команд и их описание\n" +
                "exit                    завершает работу программы");
    }

    // завершает работу программы - exit
    public static boolean exit() {
        System.out.println("Goodbye");
        return true;
    }

    private static boolean checkExistingPath(File file) {
        if (!file.exists()) {
            System.out.println("Указанный путь не существует");
           return true;
        }
        return false;
    }



}
